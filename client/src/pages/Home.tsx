import { useState, useMemo, useRef, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { Link, useLocation } from "wouter";
import Papa from "papaparse";
import { z } from "zod";
import Controls from "@/components/Controls";
import StatsStrip from "@/components/StatsStrip";
import ChartCard from "@/components/ChartCard";
import DataTable from "@/components/DataTable";
import TipExpensesTable from "@/components/TipExpensesTable";
import EntryForm from "@/components/EntryForm";
import TipExpenseForm from "@/components/TipExpenseForm";
import ConfirmDialog from "@/components/ConfirmDialog";
import TimelineFilter, { TimelineRange } from "@/components/TimelineFilter";
import ProfitCalculator from "@/components/ProfitCalculator";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { useDataStorage } from "@/hooks/use-data-storage";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import { ChevronDown, Maximize2, X, User, Upload } from "lucide-react";
import { Button } from "@/components/ui/button";

interface Entry {
  id: string;
  date: string;
  net: number;
  betAmount: number;
  winningAmount: number;
  notes?: string;
}

interface CapitalInjection {
  id: string;
  date: string;
  amount: number;
  notes?: string;
  autoGenerated?: boolean;
}

interface TipExpense {
  id: string;
  date: string;
  amount: number;
  provider?: string;
  notes?: string;
}

interface DataPoint extends Entry {
  running: number;
}

const STORAGE_KEY = "bt.entries.v1";
const BASELINE_KEY = "bt.baseline.v1";
const INJECTIONS_KEY = "bt.injections.v7";
const TIP_EXPENSES_KEY = "bt.tipExpenses.v1";
const MIGRATION_DISMISSED_KEY = "bt.migration.dismissed";

const entrySchema = z.object({
  id: z.string(),
  date: z.string(),
  net: z.coerce.number(),
  betAmount: z.coerce.number(),
  winningAmount: z.coerce.number(),
  notes: z.string().optional(),
});

const capitalInjectionSchema = z.object({
  id: z.string(),
  date: z.string(),
  amount: z.coerce.number(),
  notes: z.string().optional(),
  autoGenerated: z.boolean().optional(),
});

const tipExpenseSchema = z.object({
  id: z.string(),
  date: z.string(),
  amount: z.coerce.number(),
  provider: z.string().optional(),
  notes: z.string().optional(),
});

const entriesArraySchema = z.array(entrySchema);
const injectionsArraySchema = z.array(capitalInjectionSchema);
const tipExpensesArraySchema = z.array(tipExpenseSchema);

export default function Home() {
  const { toast } = useToast();
  const { isAuthenticated, user } = useAuth();
  const [, setLocation] = useLocation();
  
  // Check subscription status
  const { data: subscriptionData } = useQuery({
    queryKey: ['/api/subscription-status'],
    enabled: !!user,
  });
  
  const hasActiveSubscription = (subscriptionData as any)?.hasActiveSubscription || false;
  
  const { 
    entries: dbEntries, 
    injections: dbInjections,
    settings: dbSettings,
    useCloudStorage: hookUseCloudStorage,
    createEntry,
    updateEntry,
    deleteEntry,
    createInjection,
    deleteInjection,
    createSettings,
    updateSettings,
    migrateLocalData,
    isMigrating
  } = useDataStorage();
  
  // Use cloud storage flag from hook (considers both auth and subscription)
  const useCloudStorage = hookUseCloudStorage || false;
  
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [baseline, setBaseline] = useState<number | null>(null);
  const [viewMode, setViewMode] = useState<"per-bet" | "per-day">("per-bet");
  const [timelineRange, setTimelineRange] = useState<TimelineRange>("all");
  const [entries, setEntries] = useState<Entry[]>([]);
  const [capitalInjections, setCapitalInjections] = useState<CapitalInjection[]>([]);
  const [tipExpenses, setTipExpenses] = useState<TipExpense[]>([]);
  const [formOpen, setFormOpen] = useState(false);
  const [tipExpenseFormOpen, setTipExpenseFormOpen] = useState(false);
  const [editingEntry, setEditingEntry] = useState<Entry | null>(null);
  const [editingTipExpense, setEditingTipExpense] = useState<TipExpense | null>(null);
  const [confirmOpen, setConfirmOpen] = useState(false);
  const [deleteId, setDeleteId] = useState<string | null>(null);
  const [deleteTipId, setDeleteTipId] = useState<string | null>(null);
  const [calculatorOpen, setCalculatorOpen] = useState(true);
  const [chartOpen, setChartOpen] = useState(true);
  const [historyOpen, setHistoryOpen] = useState(true);
  const [tipsOpen, setTipsOpen] = useState(true);
  const [chartFullscreen, setChartFullscreen] = useState(false);
  const [showMigrationPrompt, setShowMigrationPrompt] = useState(false);

  // Check if user is authenticated and has local data to migrate
  useEffect(() => {
    if (isAuthenticated && !isMigrating) {
      // Check if user has already dismissed the migration prompt
      const dismissed = localStorage.getItem(MIGRATION_DISMISSED_KEY);
      if (dismissed === 'true') {
        return; // Don't show prompt if already dismissed
      }

      const hasLocalEntries = localStorage.getItem(STORAGE_KEY);
      const hasLocalInjections = localStorage.getItem(INJECTIONS_KEY);
      const hasLocalBaseline = localStorage.getItem(BASELINE_KEY);
      
      if (hasLocalEntries || hasLocalInjections || hasLocalBaseline) {
        setShowMigrationPrompt(true);
      }
    }
  }, [isAuthenticated, isMigrating]);

  const handleMigrate = async () => {
    try {
      await migrateLocalData();
      toast({
        title: "Data Saved",
        description: "Your betting data has been saved to your account",
      });
      setShowMigrationPrompt(false);
      // Mark migration as completed so prompt doesn't show again
      localStorage.setItem(MIGRATION_DISMISSED_KEY, 'true');
    } catch (error) {
      toast({
        title: "Migration Failed",
        description: "Failed to save data to your account",
        variant: "destructive",
      });
    }
  };

  const handleDismissMigration = () => {
    setShowMigrationPrompt(false);
    // Remember that user dismissed the prompt so it doesn't show again
    localStorage.setItem(MIGRATION_DISMISSED_KEY, 'true');
  };

  // Track the current user ID to detect user changes
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);
  
  // Track if we've loaded initial data from MongoDB to prevent overwrites
  const [hasLoadedFromMongo, setHasLoadedFromMongo] = useState(false);
  
  // Clear state when user changes or logs out
  useEffect(() => {
    // Logout case: clear everything
    if (!isAuthenticated || !user) {
      setEntries([]);
      setCapitalInjections([]);
      setBaseline(null);
      setTipExpenses([]);
      // Clear localStorage entries but keep tip expenses
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(BASELINE_KEY);
      localStorage.removeItem(INJECTIONS_KEY);
      localStorage.removeItem(MIGRATION_DISMISSED_KEY); // Reset migration prompt for next login
      setCurrentUserId(null);
      setHasLoadedFromMongo(false); // Reset load flag
      return;
    }
    
    // Login/user change case: clear if user ID changed
    if (user._id !== currentUserId) {
      setEntries([]);
      setCapitalInjections([]);
      setBaseline(null);
      setTipExpenses([]);
      // Clear localStorage betting data but keep tip expenses (no MongoDB backend yet)
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(BASELINE_KEY);
      localStorage.removeItem(INJECTIONS_KEY);
      localStorage.removeItem(MIGRATION_DISMISSED_KEY); // Reset migration prompt for new user
      setCurrentUserId(user._id);
      setHasLoadedFromMongo(false); // Reset load flag for new user
    }
  }, [isAuthenticated, user, currentUserId]);

  // Load entries and injections from MongoDB when using cloud storage
  useEffect(() => {
    if (useCloudStorage) {
      if (!hasLoadedFromMongo) {
        // Initial load: use MongoDB data as source of truth
        setEntries(dbEntries || []);
        setCapitalInjections(dbInjections || []);
        setHasLoadedFromMongo(true);
      } else if (dbEntries && dbInjections) {
        // Subsequent loads: merge MongoDB data with local state
        // MongoDB is the source of truth - use it directly
        setEntries(dbEntries);
        setCapitalInjections(dbInjections);
      }
    }
  }, [useCloudStorage, dbEntries, dbInjections, hasLoadedFromMongo]);

  // Load baseline from MongoDB when using cloud storage (separate effect to avoid circular deps)
  useEffect(() => {
    if (useCloudStorage && dbSettings) {
      // Only set baseline when settings are loaded (don't clear while loading)
      setBaseline(dbSettings.baseline);
    }
  }, [useCloudStorage, dbSettings]);

  // Always load tip expenses from localStorage (no MongoDB backend yet)
  useEffect(() => {
    // Load tip expenses on mount and when user changes
    if (!useCloudStorage || (useCloudStorage && hasLoadedFromMongo)) {
      try {
        const storedTipExpenses = localStorage.getItem(TIP_EXPENSES_KEY);
        if (storedTipExpenses) {
          const parsed = JSON.parse(storedTipExpenses);
          const validated = tipExpensesArraySchema.safeParse(parsed);
          
          if (validated.success) {
            setTipExpenses(validated.data);
          } else {
            console.error("Invalid tip expenses in localStorage, clearing:", validated.error);
            localStorage.removeItem(TIP_EXPENSES_KEY);
          }
        } else {
          // No tip expenses in storage, clear state
          setTipExpenses([]);
        }
      } catch (error) {
        console.error("Failed to load tip expenses from localStorage:", error);
        localStorage.removeItem(TIP_EXPENSES_KEY);
      }
    }
  }, [useCloudStorage, hasLoadedFromMongo]); // Load when cloud storage status changes or after MongoDB loads

  // Load from localStorage when not using cloud storage (only runs once on mount)
  useEffect(() => {
    if (!useCloudStorage) {
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('clear') === 'true') {
        localStorage.clear();
        console.log('=== CLEARED ALL LOCALSTORAGE ===');
        window.location.href = window.location.pathname;
        return;
      }
      
      localStorage.removeItem('bt.injections.v1');
      localStorage.removeItem('bt.injections.v2');
      localStorage.removeItem('bt.injections.v3');
      localStorage.removeItem('bt.injections.v4');
      localStorage.removeItem('bt.injections.v5');
      localStorage.removeItem('bt.injections.v6');
      localStorage.removeItem('bt.injections.v7');
      
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          const parsed = JSON.parse(stored);
          const validated = entriesArraySchema.safeParse(parsed);
          
          if (validated.success) {
            setEntries(validated.data);
          } else {
            console.error("Invalid entries in localStorage, clearing:", validated.error);
            localStorage.removeItem(STORAGE_KEY);
          }
        }

        const storedBaseline = localStorage.getItem(BASELINE_KEY);
        if (storedBaseline) {
          const baselineValue = Number(storedBaseline);
          if (isFinite(baselineValue)) {
            setBaseline(baselineValue);
          }
        }

        const storedInjections = localStorage.getItem(INJECTIONS_KEY);
        if (storedInjections) {
          const parsed = JSON.parse(storedInjections);
          const validated = injectionsArraySchema.safeParse(parsed);
          
          if (validated.success) {
            setCapitalInjections(validated.data);
          } else {
            console.error("Invalid injections in localStorage, clearing:", validated.error);
            localStorage.removeItem(INJECTIONS_KEY);
          }
        }

        const storedTipExpenses = localStorage.getItem(TIP_EXPENSES_KEY);
        if (storedTipExpenses) {
          const parsed = JSON.parse(storedTipExpenses);
          const validated = tipExpensesArraySchema.safeParse(parsed);
          
          if (validated.success) {
            setTipExpenses(validated.data);
          } else {
            console.error("Invalid tip expenses in localStorage, clearing:", validated.error);
            localStorage.removeItem(TIP_EXPENSES_KEY);
          }
        }
      } catch (error) {
        console.error("Failed to load from localStorage:", error);
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(BASELINE_KEY);
        localStorage.removeItem(INJECTIONS_KEY);
        localStorage.removeItem(TIP_EXPENSES_KEY);
      }
    }
  }, [useCloudStorage]);

  // Only save to localStorage when not using cloud storage
  useEffect(() => {
    if (!useCloudStorage) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(entries));
      } catch (error) {
        console.error("Failed to save to localStorage:", error);
      }
    }
  }, [entries, useCloudStorage]);

  useEffect(() => {
    if (!useCloudStorage) {
      try {
        if (baseline !== null) {
          localStorage.setItem(BASELINE_KEY, baseline.toString());
        } else {
          localStorage.removeItem(BASELINE_KEY);
        }
      } catch (error) {
        console.error("Failed to save baseline to localStorage:", error);
      }
    }
  }, [baseline, useCloudStorage]);

  // Sync baseline to MongoDB when using cloud storage and baseline changes
  useEffect(() => {
    if (useCloudStorage && baseline !== null) {
      if (dbSettings) {
        // Only update if different from what's in the database
        if (dbSettings.baseline !== baseline) {
          updateSettings({ baseline }).catch(error => {
            console.error("Failed to update baseline in MongoDB:", error);
          });
        }
      } else {
        // Create settings if they don't exist
        createSettings({ 
          baseline, 
          weekStartDate: new Date().toISOString().split('T')[0] 
        }).catch(error => {
          console.error("Failed to create settings in MongoDB:", error);
        });
      }
    }
  }, [baseline, useCloudStorage, dbSettings, updateSettings, createSettings]);

  useEffect(() => {
    if (!useCloudStorage) {
      try {
        localStorage.setItem(INJECTIONS_KEY, JSON.stringify(capitalInjections));
      } catch (error) {
        console.error("Failed to save capital injections to localStorage:", error);
      }
    }
  }, [capitalInjections, useCloudStorage]);

  // Always save tip expenses to localStorage (no MongoDB backend for tips yet)
  useEffect(() => {
    try {
      localStorage.setItem(TIP_EXPENSES_KEY, JSON.stringify(tipExpenses));
    } catch (error) {
      console.error("Failed to save tip expenses to localStorage:", error);
    }
  }, [tipExpenses]);

  // Auto-generate capital injections only for localStorage users
  useEffect(() => {
    if (!useCloudStorage && baseline !== null && entries.length > 0) {
      const sorted = [...entries].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
      
      console.log('=== CAPITAL INJECTION CALCULATION ===');
      console.log('Baseline:', baseline);
      console.log('Total Entries:', sorted.length);
      
      const userCreatedInjections = capitalInjections.filter(inj => !inj.autoGenerated);
      console.log('User-created injections to preserve:', userCreatedInjections.length);
      
      const autoGeneratedInjections: CapitalInjection[] = [];
      const existingDates = new Set(userCreatedInjections.map(inj => new Date(inj.date).getTime()));
      let running = baseline;
      let bankroll = Math.abs(baseline);
      const injectionDates = new Set<number>();
      const firstEntryId = sorted[0]?.id;
      
      for (const entry of sorted) {
        const beforeBankroll = bankroll;
        const entryTime = new Date(entry.date).getTime();
        
        // Check if we need capital injection to place the bet
        if (entry.betAmount > bankroll) {
          const neededCapital = entry.betAmount - bankroll;
          if (!injectionDates.has(entryTime) && !existingDates.has(entryTime)) {
            console.log(`  → INJECTION NEEDED: bankroll=${bankroll}, betAmount=${entry.betAmount}, inject ${neededCapital}`);
            autoGeneratedInjections.push({
              id: `${Date.now()}-${Math.random()}`,
              date: entry.date,
              amount: neededCapital,
              notes: `Auto-generated: needed $${neededCapital.toLocaleString()} to place $${entry.betAmount.toLocaleString()} bet`,
              autoGenerated: true,
            });
            injectionDates.add(entryTime);
            bankroll += neededCapital;
            console.log(`  → After injection: bankroll=${bankroll}`);
          }
        }
        
        // Update bankroll with bet result
        bankroll += entry.net;
        console.log(`Entry ${entry.date}: bet=${entry.betAmount}, net=${entry.net}, bankroll: ${beforeBankroll} → ${bankroll}`);
        
        // Update running balance for display
        if (entry.id === firstEntryId && entry.net >= 0) {
          running += entry.betAmount + entry.net;
        } else {
          running += entry.net;
        }
      }
      
      console.log('Auto-generated injections:', autoGeneratedInjections.length);
      console.log('Total injections (user + auto):', userCreatedInjections.length + autoGeneratedInjections.length);
      console.log('=== END CAPITAL INJECTION CALCULATION ===');
      
      const mergedInjections = [...userCreatedInjections, ...autoGeneratedInjections];
      setCapitalInjections(mergedInjections);
    }
  }, [baseline, entries, useCloudStorage, toast]);

  const getCutoffDate = (range: TimelineRange): Date | null => {
    if (range === "all") return null;

    const now = new Date();
    const cutoffDate = new Date(now);

    switch (range) {
      case "1d":
        // Last 24 hours
        cutoffDate.setTime(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case "3d":
        // Last 3 days (72 hours)
        cutoffDate.setTime(now.getTime() - 3 * 24 * 60 * 60 * 1000);
        break;
      case "1w":
        // Last 7 days
        cutoffDate.setTime(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case "2w":
        // Last 14 days
        cutoffDate.setTime(now.getTime() - 14 * 24 * 60 * 60 * 1000);
        break;
      case "1m":
        // Last 30 days (approximate month)
        cutoffDate.setTime(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      case "3m":
        // Last 90 days (approximate 3 months)
        cutoffDate.setTime(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        break;
      case "6m":
        // Last 180 days (approximate 6 months)
        cutoffDate.setTime(now.getTime() - 180 * 24 * 60 * 60 * 1000);
        break;
      case "1y":
        // Last 365 days (approximate year)
        cutoffDate.setTime(now.getTime() - 365 * 24 * 60 * 60 * 1000);
        break;
      case "ytd":
        // Year to date - from Jan 1 of current year
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        return new Date(today.getFullYear(), 0, 1);
    }

    return cutoffDate;
  };

  const { filteredData, startingBalance, firstEntryId } = useMemo(() => {
    const sorted = [...entries].sort(
      (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()
    );

    const firstId = sorted.length > 0 ? sorted[0].id : null;

    const cutoffDate = getCutoffDate(timelineRange);
    
    // "All" view shows everything including future-dated entries
    if (!cutoffDate) {
      return {
        filteredData: sorted,
        startingBalance: baseline ?? 0,
        firstEntryId: firstId,
      };
    }

    // For time-based ranges, show entries from cutoff to now (rolling window)
    const now = new Date();
    const beforeCutoff = sorted.filter((e) => new Date(e.date) < cutoffDate);
    const afterCutoff = sorted.filter((e) => {
      const entryDate = new Date(e.date);
      // Include entries within the time window (cutoffDate to now)
      return entryDate >= cutoffDate && entryDate <= now;
    });

    let balanceBeforeCutoff = baseline ?? 0;
    beforeCutoff.forEach((e) => {
      if (e.id === firstId && e.net >= 0) {
        balanceBeforeCutoff += e.betAmount + e.net;
      } else {
        balanceBeforeCutoff += e.net;
      }
    });

    return {
      filteredData: afterCutoff,
      startingBalance: balanceBeforeCutoff,
      firstEntryId: firstId,
    };
  }, [entries, timelineRange, baseline]);

  const dataPoints = useMemo(() => {
    if (viewMode === "per-day") {
      const dailyGroups = new Map<string, Entry[]>();
      
      for (const entry of filteredData) {
        const dateKey = entry.date.split("T")[0];
        if (!dailyGroups.has(dateKey)) {
          dailyGroups.set(dateKey, []);
        }
        dailyGroups.get(dateKey)!.push(entry);
      }

      const aggregated: DataPoint[] = [];
      let running = startingBalance;

      for (const [dateKey, dayEntries] of Array.from(dailyGroups.entries()).sort()) {
        const totalNet = dayEntries.reduce((sum, e) => sum + e.net, 0);
        const totalBet = dayEntries.reduce((sum, e) => sum + e.betAmount, 0);
        const totalWinning = dayEntries.reduce((sum, e) => sum + e.winningAmount, 0);
        const notes = `${dayEntries.length} ${dayEntries.length === 1 ? "bet" : "bets"}`;

        const isFirstEntryInDay = dayEntries.some((e) => e.id === firstEntryId);
        const firstEntry = dayEntries.find((e) => e.id === firstEntryId);

        if (isFirstEntryInDay && firstEntry && firstEntry.net >= 0) {
          running += firstEntry.betAmount + firstEntry.net;
          const remainingNet = totalNet - firstEntry.net;
          running += remainingNet;
        } else {
          running += totalNet;
        }

        aggregated.push({
          id: dateKey,
          date: `${dateKey}T12:00`,
          net: totalNet,
          betAmount: totalBet,
          winningAmount: totalWinning,
          notes,
          running,
        });
      }

      return aggregated;
    } else {
      let running = startingBalance;
      
      return filteredData.map((entry) => {
        if (entry.id === firstEntryId && entry.net >= 0) {
          running += entry.betAmount + entry.net;
        } else {
          running += entry.net;
        }
        return { ...entry, running };
      });
    }
  }, [filteredData, startingBalance, firstEntryId, viewMode]);
  
  const currentBalance = dataPoints.length > 0 ? dataPoints[dataPoints.length - 1].running : startingBalance;
  const netPL = currentBalance; // Current balance already accounts for recouped capital
  const peakBalance = Math.max(...dataPoints.map((d) => d.running), startingBalance);
  
  let peak = startingBalance;
  let maxDrawdown = 0;
  for (const d of dataPoints) {
    peak = Math.max(peak, d.running);
    const drawdown = d.running - peak;
    maxDrawdown = Math.min(maxDrawdown, drawdown);
  }
  
  const totalInjections = capitalInjections.reduce((sum, inj) => sum + inj.amount, 0);
  const totalTipExpenses = tipExpenses.reduce((sum, expense) => sum + expense.amount, 0);
  const totalCapitalInvested = Math.abs(baseline ?? 0) + totalInjections;
  // True profit = betting profit/loss minus tip expenses
  const trueProfitAfterTips = netPL - totalTipExpenses;
  
  console.log('=== STATS CALCULATION ===');
  console.log('Baseline (Starting Bet):', baseline);
  console.log('Starting Balance (timeline):', startingBalance);
  console.log('Capital Injections:', capitalInjections);
  console.log('Total Injections Amount:', totalInjections);
  console.log('Tip Expenses:', tipExpenses);
  console.log('Total Tip Expenses:', totalTipExpenses);
  console.log('Total Capital Invested (baseline + injections):', `${Math.abs(baseline ?? 0)} + ${totalInjections} = ${totalCapitalInvested}`);
  console.log('Current Balance (from bets):', currentBalance);
  console.log('Net P/L (from bets):', netPL);
  console.log('Peak Balance:', peakBalance);
  console.log('Max Drawdown:', maxDrawdown);
  console.log('True Profit After Tips:', trueProfitAfterTips);
  console.log('=== END STATS ===');

  const handleAddEntry = () => {
    setEditingEntry(null);
    setFormOpen(true);
  };

  const handleEditEntry = (id: string) => {
    const entry = entries.find((e) => e.id === id);
    if (entry) {
      setEditingEntry(entry);
      setFormOpen(true);
    }
  };

  const handleDeleteEntry = (id: string) => {
    setDeleteId(id);
    setConfirmOpen(true);
  };

  const confirmDelete = async () => {
    if (deleteId) {
      if (useCloudStorage) {
        try {
          await deleteEntry(deleteId);
        } catch (error) {
          toast({
            title: "Delete Failed",
            description: "Failed to delete entry from cloud storage",
            variant: "destructive",
          });
        }
      } else {
        setEntries(entries.filter((e) => e.id !== deleteId));
      }
      setDeleteId(null);
    }
    if (deleteTipId) {
      setTipExpenses(tipExpenses.filter((e) => e.id !== deleteTipId));
      setDeleteTipId(null);
    }
    setConfirmOpen(false);
  };

  const handleSaveEntry = async (entryData: { date: string; net: number; betAmount: number; winningAmount: number; notes: string }) => {
    if (editingEntry) {
      // Editing existing entry
      if (useCloudStorage) {
        try {
          await updateEntry({ id: editingEntry.id, data: entryData });
          setEditingEntry(null);
        } catch (error) {
          toast({
            title: "Update Failed",
            description: "Failed to update entry in cloud storage",
            variant: "destructive",
          });
        }
      } else {
        // localStorage mode: update local state
        setEntries(
          entries.map((e) =>
            e.id === editingEntry.id ? { ...e, ...entryData } : e
          )
        );
        setEditingEntry(null);
      }
    } else {
      // Adding new entry
      if (useCloudStorage) {
        try {
          await createEntry(entryData);
          
          // Check if we need to auto-generate capital injection
          if (baseline !== null && entryData.net < 0) {
            const allEntries = [...entries, { id: 'temp', ...entryData }];
            const sorted = [...allEntries].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
            const allInjectionDates = new Set(capitalInjections.map(inj => new Date(inj.date).getTime()));
            const injectionsByDate = new Map(capitalInjections.map(inj => [new Date(inj.date).getTime(), inj.amount]));
            
            let running = baseline;
            for (const entry of sorted) {
              running += entry.net;
              
              const entryTime = new Date(entry.date).getTime();
              if (injectionsByDate.has(entryTime)) {
                running += injectionsByDate.get(entryTime)!;
              }
              
              if (running < baseline && entry.net < 0 && entry.id === 'temp') {
                const alreadyExists = allInjectionDates.has(entryTime);
                
                if (!alreadyExists) {
                  const injectionAmount = Math.abs(running - baseline);
                  await createInjection({
                    date: entry.date,
                    amount: injectionAmount,
                    notes: `Auto-generated: balance went below starting line`,
                    autoGenerated: true,
                  });
                  break;
                }
              }
            }
          }
        } catch (error) {
          toast({
            title: "Save Failed",
            description: "Failed to save entry to your account",
            variant: "destructive",
          });
        }
      } else {
        const newEntry: Entry = {
          id: `${Date.now()}-${Math.random()}`,
          ...entryData,
        };
        const updatedEntries = [...entries, newEntry];
        
        if (baseline !== null && entryData.net < 0) {
          const sorted = [...updatedEntries].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
          const allInjectionDates = new Set(capitalInjections.map(inj => new Date(inj.date).getTime()));
          const injectionsByDate = new Map(capitalInjections.map(inj => [new Date(inj.date).getTime(), inj.amount]));
          
          let running = baseline;
          for (const entry of sorted) {
            running += entry.net;
            
            const entryTime = new Date(entry.date).getTime();
            if (injectionsByDate.has(entryTime)) {
              running += injectionsByDate.get(entryTime)!;
            }
            
            if (running < baseline && entry.net < 0 && entry.id === newEntry.id) {
              const alreadyExists = allInjectionDates.has(entryTime);
              
              if (!alreadyExists) {
                const injectionAmount = Math.abs(running - baseline);
                const newInjection: CapitalInjection = {
                  id: `${Date.now()}-${Math.random()}`,
                  date: entry.date,
                  amount: injectionAmount,
                  notes: `Auto-generated: balance went below starting line`,
                  autoGenerated: true,
                };
                setCapitalInjections([...capitalInjections, newInjection]);
                break;
              }
            }
          }
        }
        
        setEntries(updatedEntries);
      }
    }
  };

  const handleAddTipExpense = () => {
    setEditingTipExpense(null);
    setTipExpenseFormOpen(true);
  };

  const handleEditTipExpense = (id: string) => {
    const expense = tipExpenses.find((e) => e.id === id);
    if (expense) {
      setEditingTipExpense(expense);
      setTipExpenseFormOpen(true);
    }
  };

  const handleDeleteTipExpense = (id: string) => {
    setDeleteTipId(id);
    setConfirmOpen(true);
  };

  const handleSaveTipExpense = (expenseData: { date: string; amount: number; provider: string; notes: string }) => {
    if (editingTipExpense) {
      setTipExpenses(
        tipExpenses.map((e) =>
          e.id === editingTipExpense.id ? { ...e, ...expenseData } : e
        )
      );
      toast({
        title: "Tip Payment Updated",
        description: `Updated $${expenseData.amount.toLocaleString()} payment`,
      });
    } else {
      const newExpense: TipExpense = {
        id: `${Date.now()}-${Math.random()}`,
        ...expenseData,
      };
      setTipExpenses([...tipExpenses, newExpense]);
      
      toast({
        title: "Tip Payment Added",
        description: `Recorded $${expenseData.amount.toLocaleString()} payment`,
      });
    }
  };

  const handleClearAll = () => {
    setConfirmOpen(true);
  };

  const confirmClearAll = () => {
    if (deleteId === null && deleteTipId === null) {
      setEntries([]);
      setCapitalInjections([]);
      setTipExpenses([]);
    }
    setConfirmOpen(false);
  };

  const handleImportCsv = () => {
    fileInputRef.current?.click();
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse(file, {
      header: true,
      complete: (results) => {
        try {
          const importedEntries: Entry[] = [];
          const importedTips: TipExpense[] = [];
          const existingEntryKeys = new Set(
            entries.map((e) => `${e.date}-${e.notes}-${e.net}`)
          );
          const existingTipKeys = new Set(
            tipExpenses.map((t) => `${t.date}-${t.notes}-${t.amount}`)
          );
          let skippedCount = 0;
          let invalidCount = 0;
          
          // Variables to store config values
          let importedBaseline: number | null = null;
          let hasConfigRows = false;
          
          // Default calculator settings to use when config is missing
          const today = new Date().toISOString().split('T')[0];
          const calcConfig: any = {
            weeklyProfitGoal: 500,
            tipPricingType: "weekly",
            weeklyPackagePrice: 100,
            perBetTipPrice: 10,
            estimatedBetsPerWeek: 10,
            weekStartDate: today,
          };

          for (const row of results.data as any[]) {
            // Skip completely empty rows
            if (!row.date || !row.type) {
              continue;
            }

            // Check if this is a config row
            if (row.type === "Config") {
              hasConfigRows = true;
              if (row.date === "startingBet" && row.betAmount) {
                importedBaseline = Number(row.betAmount);
              } else if (row.date === "weeklyProfitGoal" && row.betAmount) {
                calcConfig.weeklyProfitGoal = Number(row.betAmount);
              } else if (row.date === "tipPricingType" && row.provider) {
                calcConfig.tipPricingType = row.provider;
              } else if (row.date === "weeklyPackagePrice" && row.betAmount) {
                calcConfig.weeklyPackagePrice = Number(row.betAmount);
              } else if (row.date === "perBetTipPrice" && row.betAmount) {
                calcConfig.perBetTipPrice = Number(row.betAmount);
              } else if (row.date === "estimatedBetsPerWeek" && row.betAmount) {
                calcConfig.estimatedBetsPerWeek = Number(row.betAmount);
              } else if (row.date === "weekStartDate" && row.notes) {
                calcConfig.weekStartDate = row.notes;
              }
              continue;
            }

            // Check if this is a tip expense row
            if (row.type === "Tip") {
              const tipAmount = Number(row.tipAmount || 0);
              
              if (isNaN(tipAmount) || tipAmount === 0) {
                invalidCount++;
                continue;
              }

              const tipKey = `${row.date}-${row.notes || ""}-${tipAmount}`;
              if (existingTipKeys.has(tipKey)) {
                skippedCount++;
                continue;
              }

              importedTips.push({
                id: Date.now().toString() + Math.random(),
                date: row.date,
                amount: tipAmount,
                provider: row.provider || "",
                notes: row.notes || "",
              });
            } 
            // Otherwise, treat as betting entry
            else if (row.type === "Bet") {
              const net = Number(row.net);
              const betAmount = Number(row.betAmount);
              const winningAmount = Number(row.winningAmount);

              // Skip invalid or empty bet entries
              if (isNaN(net) || isNaN(betAmount) || isNaN(winningAmount)) {
                invalidCount++;
                continue;
              }

              // Skip entries where bet amount is 0 (likely empty/invalid row)
              if (betAmount === 0 && winningAmount === 0 && net === 0) {
                continue;
              }

              const key = `${row.date}-${row.notes || ""}-${net}`;
              if (existingEntryKeys.has(key)) {
                skippedCount++;
                continue;
              }

              importedEntries.push({
                id: Date.now().toString() + Math.random(),
                date: row.date,
                net,
                betAmount,
                winningAmount,
                notes: row.notes || "",
              });
            }
          }

          if (importedEntries.length > 0) {
            // Save to MongoDB if using cloud storage, otherwise save to local state
            if (useCloudStorage) {
              // Save each imported entry to MongoDB
              const savePromises = importedEntries.map(entry => {
                const { id, ...entryData } = entry;
                return createEntry(entryData).catch(error => {
                  console.error("Failed to save CSV entry to MongoDB:", error);
                });
              });
              
              Promise.all(savePromises).then(() => {
                // After saving, entries will be loaded from MongoDB via the load effect
                toast({
                  title: "Import Complete",
                  description: `${importedEntries.length} ${importedEntries.length === 1 ? "bet" : "bets"} imported`,
                });
              });
            } else {
              // localStorage mode: update local state directly
              const combinedEntries = [...entries, ...importedEntries];
              const sorted = combinedEntries.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
              const firstEntry = sorted[0];
              const firstEntryId = firstEntry?.id;
              
              const newInjections: CapitalInjection[] = [];
              
              if (baseline !== null) {
                let running = baseline;
                const allInjectionDates = new Set(capitalInjections.map(inj => new Date(inj.date).getTime()));
                
                for (const entry of sorted) {
                  running += entry.net;
                  
                  if (running < baseline && entry.net < 0) {
                    const entryTime = new Date(entry.date).getTime();
                    const alreadyExists = allInjectionDates.has(entryTime) || 
                      newInjections.some(inj => new Date(inj.date).getTime() === entryTime);
                    
                    if (!alreadyExists) {
                      const injectionAmount = Math.abs(running - baseline);
                      newInjections.push({
                        id: `${Date.now()}-${Math.random()}`,
                        date: entry.date,
                        amount: injectionAmount,
                        notes: `Auto-generated: balance went below starting line`,
                        autoGenerated: true,
                      });
                      allInjectionDates.add(entryTime);
                      running += injectionAmount;
                    }
                  }
                }
              }
              
              setEntries(sorted);
              if (newInjections.length > 0) {
                setCapitalInjections([...capitalInjections, ...newInjections]);
              }
            }
          }

          if (importedTips.length > 0) {
            setTipExpenses([...tipExpenses, ...importedTips]);
          }

          // Apply imported baseline if found
          if (importedBaseline !== null) {
            setBaseline(importedBaseline);
          }

          // Apply calculator settings (either imported values or defaults if config rows were found)
          if (hasConfigRows) {
            localStorage.setItem("bt.profitCalc.v1", JSON.stringify(calcConfig));
          }

          // Only show toast for non-MongoDB mode or for other imported data (tips, baseline, config)
          if (!useCloudStorage || importedTips.length > 0 || importedBaseline !== null || hasConfigRows) {
            const messages = [];
            if (!useCloudStorage && importedEntries.length > 0) {
              messages.push(`${importedEntries.length} ${importedEntries.length === 1 ? "bet" : "bets"}`);
            }
            if (importedTips.length > 0) messages.push(`${importedTips.length} ${importedTips.length === 1 ? "tip" : "tips"}`);
            if (importedBaseline !== null) messages.push("starting bet restored");
            if (hasConfigRows) messages.push("calculator settings restored");
            if (skippedCount > 0) messages.push(`${skippedCount} duplicate${skippedCount === 1 ? "" : "s"} skipped`);
            if (invalidCount > 0) messages.push(`${invalidCount} invalid row${invalidCount === 1 ? "" : "s"} skipped`);
            
            if (messages.length > 0) {
              toast({
                title: "Import Complete",
                description: messages.join(", "),
              });
              
              // Reload page if config was imported so ProfitCalculator can pick up new settings
              if (hasConfigRows) {
                setTimeout(() => {
                  window.location.reload();
                }, 1000);
              }
            } else if (!useCloudStorage) {
              toast({
                title: "No Data Imported",
                description: "CSV file is empty or contains only duplicates",
              });
            }
          }
        } catch (error) {
          toast({
            title: "Import Failed",
            description: "Error parsing CSV file. Please check the format.",
            variant: "destructive",
          });
        }
      },
      error: () => {
        toast({
          title: "Import Failed",
          description: "Could not read the CSV file.",
          variant: "destructive",
        });
      },
    });

    event.target.value = "";
  };

  const handleExportCsv = () => {
    const sortedEntries = [...entries].sort(
      (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()
    );
    
    const sortedTips = [...tipExpenses].sort(
      (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()
    );

    // Get profit calculator settings from localStorage
    const calcSettings = localStorage.getItem("bt.profitCalc.v1");
    let calcData: any = {};
    if (calcSettings) {
      try {
        calcData = JSON.parse(calcSettings);
      } catch (e) {
        console.error("Failed to parse calculator settings:", e);
      }
    }

    // Add config row for baseline (starting bet)
    const configRows = [
      {
        type: "Config",
        date: "startingBet",
        betAmount: baseline || "",
        winningAmount: "",
        net: "",
        tipAmount: "",
        provider: "",
        notes: "",
      },
      {
        type: "Config",
        date: "weeklyProfitGoal",
        betAmount: calcData.weeklyProfitGoal || "",
        winningAmount: "",
        net: "",
        tipAmount: "",
        provider: "",
        notes: "",
      },
      {
        type: "Config",
        date: "tipPricingType",
        betAmount: "",
        winningAmount: "",
        net: "",
        tipAmount: "",
        provider: calcData.tipPricingType || "",
        notes: "",
      },
      {
        type: "Config",
        date: "weeklyPackagePrice",
        betAmount: calcData.weeklyPackagePrice || "",
        winningAmount: "",
        net: "",
        tipAmount: "",
        provider: "",
        notes: "",
      },
      {
        type: "Config",
        date: "perBetTipPrice",
        betAmount: calcData.perBetTipPrice || "",
        winningAmount: "",
        net: "",
        tipAmount: "",
        provider: "",
        notes: "",
      },
      {
        type: "Config",
        date: "estimatedBetsPerWeek",
        betAmount: calcData.estimatedBetsPerWeek || "",
        winningAmount: "",
        net: "",
        tipAmount: "",
        provider: "",
        notes: "",
      },
      {
        type: "Config",
        date: "weekStartDate",
        betAmount: "",
        winningAmount: "",
        net: "",
        tipAmount: "",
        provider: "",
        notes: calcData.weekStartDate || "",
      },
    ];

    const betsData = sortedEntries.map((entry) => ({
      type: "Bet",
      date: entry.date,
      betAmount: entry.betAmount,
      winningAmount: entry.winningAmount,
      net: entry.net,
      tipAmount: "",
      provider: "",
      notes: entry.notes || "",
    }));

    const tipsData = sortedTips.map((tip) => ({
      type: "Tip",
      date: tip.date,
      betAmount: "",
      winningAmount: "",
      net: "",
      tipAmount: tip.amount,
      provider: tip.provider || "",
      notes: tip.notes || "",
    }));

    const allData = [...configRows, ...betsData, ...tipsData].sort((a, b) => {
      // Config rows always come first
      if (a.type === "Config" && b.type !== "Config") return -1;
      if (a.type !== "Config" && b.type === "Config") return 1;
      if (a.type === "Config" && b.type === "Config") return 0;
      
      return new Date(a.date).getTime() - new Date(b.date).getTime();
    });

    const csv = Papa.unparse(allData);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    
    link.setAttribute("href", url);
    link.setAttribute("download", `betting-tracker-${new Date().toISOString().split("T")[0]}.csv`);
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    toast({
      title: "Export Successful",
      description: `Exported ${sortedEntries.length} bet${sortedEntries.length === 1 ? "" : "s"} and ${sortedTips.length} tip${sortedTips.length === 1 ? "" : "s"}`,
    });
  };

  return (
    <div className="min-h-screen bg-background">
      <div className="border-b bg-card">
        <div className="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
          <h1 className="text-xl font-bold">Sports Betting Tracker</h1>
          <div className="flex items-center gap-2">
            {user ? (
              <>
                {hasActiveSubscription ? (
                  <span className="text-xs px-2 py-1 bg-green-500/10 text-green-500 rounded-md font-medium" data-testid="badge-premium">
                    Premium
                  </span>
                ) : (
                  <Link href="/subscribe">
                    <Button size="sm" variant="default" data-testid="button-subscribe">
                      Subscribe
                    </Button>
                  </Link>
                )}
                <Link href="/account">
                  <Button variant="ghost" size="sm" data-testid="link-account">
                    <User className="w-4 h-4 mr-2" />
                    {user.username}
                  </Button>
                </Link>
              </>
            ) : (
              <>
                <Link href="/login">
                  <Button variant="ghost" size="sm" data-testid="link-login">
                    Log in
                  </Button>
                </Link>
                <Link href="/signup">
                  <Button size="sm" data-testid="link-signup">
                    Sign up
                  </Button>
                </Link>
              </>
            )}
          </div>
        </div>
      </div>

      {/* Migration prompt banner */}
      {showMigrationPrompt && (
        <div className="bg-blue-500/10 border-b border-blue-500/20">
          <div className="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Upload className="w-5 h-5 text-blue-500" />
              <div>
                <p className="font-medium">Save Your Data to Your Account</p>
                <p className="text-sm text-muted-foreground">
                  You have local betting data. Save it to your account to access it from anywhere.
                </p>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <Button
                variant="ghost"
                size="sm"
                onClick={handleDismissMigration}
                data-testid="button-dismiss-migration"
              >
                Not now
              </Button>
              <Button
                size="sm"
                onClick={handleMigrate}
                disabled={isMigrating}
                data-testid="button-save-to-account"
              >
                {isMigrating ? "Saving..." : "Save to Account"}
              </Button>
            </div>
          </div>
        </div>
      )}

      <Controls
        baseline={baseline}
        onBaselineChange={setBaseline}
        viewMode={viewMode}
        onViewModeChange={setViewMode}
        onAddEntry={handleAddEntry}
        onAddTipExpense={handleAddTipExpense}
        onImportCsv={handleImportCsv}
        onExportCsv={handleExportCsv}
        onClear={handleClearAll}
        hasEntries={entries.length > 0}
      />

      <div className="max-w-7xl mx-auto p-2 sm:p-4 space-y-2 sm:space-y-6 pb-8">
        <StatsStrip
          currentBalance={currentBalance}
          peakBalance={peakBalance}
          maxDrawdown={maxDrawdown}
          totalCapitalInvested={totalCapitalInvested}
          totalTipsPaid={totalTipExpenses}
          trueProfitAfterTips={trueProfitAfterTips}
        />

        <Collapsible open={calculatorOpen} onOpenChange={setCalculatorOpen}>
          <div className="flex items-center justify-between">
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                className="flex items-center gap-2 p-0 hover:bg-transparent"
                data-testid="button-toggle-calculator"
              >
                <h2 className="text-lg sm:text-xl font-bold">Profit Calculator</h2>
                <ChevronDown
                  className={`h-4 w-4 transition-transform ${calculatorOpen ? "rotate-180" : ""}`}
                />
              </Button>
            </CollapsibleTrigger>
          </div>
          <CollapsibleContent className="pt-4">
            <ProfitCalculator 
              entries={entries} 
              tipExpenses={tipExpenses}
              baseline={baseline}
              capitalInjections={capitalInjections}
            />
          </CollapsibleContent>
        </Collapsible>

        <Collapsible open={chartOpen} onOpenChange={setChartOpen}>
          <div className="flex items-center justify-between">
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                className="flex items-center gap-2 p-0 hover:bg-transparent"
                data-testid="button-toggle-chart"
              >
                <h2 className="text-lg sm:text-xl font-bold">Balance Over Time</h2>
                <ChevronDown
                  className={`h-4 w-4 transition-transform ${chartOpen ? "rotate-180" : ""}`}
                />
              </Button>
            </CollapsibleTrigger>
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setChartFullscreen(true)}
              className="hover-elevate active-elevate-2"
              data-testid="button-fullscreen-chart"
              aria-label="Open chart in fullscreen"
            >
              <Maximize2 className="h-4 w-4" />
            </Button>
          </div>
          <CollapsibleContent className="pt-4 space-y-4">
            <TimelineFilter
              selected={timelineRange}
              onSelect={setTimelineRange}
            />
            <ChartCard data={dataPoints} baseline={startingBalance} capitalInjections={capitalInjections} timelineRange={timelineRange} />
          </CollapsibleContent>
        </Collapsible>

        {chartFullscreen && (
          <div className="fixed inset-0 z-50 bg-background flex flex-col">
            <div className="flex items-center justify-between p-4 border-b">
              <h2 className="text-xl font-bold">Balance Over Time</h2>
              <Button
                variant="ghost"
                size="icon"
                onClick={() => setChartFullscreen(false)}
                className="hover-elevate active-elevate-2"
                data-testid="button-close-fullscreen"
                aria-label="Close fullscreen"
              >
                <X className="h-5 w-5" />
              </Button>
            </div>
            <div className="flex-1 overflow-auto p-4 space-y-4">
              <TimelineFilter
                selected={timelineRange}
                onSelect={setTimelineRange}
              />
              <div className="h-[calc(100vh-200px)]">
                <ChartCard data={dataPoints} baseline={startingBalance} capitalInjections={capitalInjections} timelineRange={timelineRange} />
              </div>
            </div>
          </div>
        )}

        <Collapsible open={historyOpen} onOpenChange={setHistoryOpen}>
          <div className="flex items-center justify-between">
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                className="flex items-center gap-2 p-0 hover:bg-transparent"
                data-testid="button-toggle-history"
              >
                <h2 className="text-lg sm:text-xl font-bold">Bet History</h2>
                <ChevronDown
                  className={`h-4 w-4 transition-transform ${historyOpen ? "rotate-180" : ""}`}
                />
              </Button>
            </CollapsibleTrigger>
          </div>
          <CollapsibleContent className="pt-4">
            <DataTable
              entries={dataPoints}
              onEdit={handleEditEntry}
              onDelete={handleDeleteEntry}
              onAddEntry={handleAddEntry}
            />
          </CollapsibleContent>
        </Collapsible>

        <Collapsible open={tipsOpen} onOpenChange={setTipsOpen}>
          <div className="flex items-center justify-between">
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                className="flex items-center gap-2 p-0 hover:bg-transparent"
                data-testid="button-toggle-tips"
              >
                <h2 className="text-lg sm:text-xl font-bold">Tip Expenses</h2>
                <ChevronDown
                  className={`h-4 w-4 transition-transform ${tipsOpen ? "rotate-180" : ""}`}
                />
              </Button>
            </CollapsibleTrigger>
          </div>
          <CollapsibleContent className="pt-4">
            <TipExpensesTable
              tipExpenses={tipExpenses}
              onEdit={handleEditTipExpense}
              onDelete={handleDeleteTipExpense}
              onAddTipPayment={handleAddTipExpense}
            />
          </CollapsibleContent>
        </Collapsible>
      </div>

      <EntryForm
        key={editingEntry?.id ?? 'new'}
        open={formOpen}
        onClose={() => {
          setFormOpen(false);
          setEditingEntry(null);
        }}
        onSave={handleSaveEntry}
        initialData={editingEntry || undefined}
      />

      <TipExpenseForm
        open={tipExpenseFormOpen}
        onClose={() => setTipExpenseFormOpen(false)}
        onSave={handleSaveTipExpense}
        initialData={editingTipExpense || undefined}
      />

      <ConfirmDialog
        open={confirmOpen}
        onClose={() => setConfirmOpen(false)}
        onConfirm={deleteId || deleteTipId ? confirmDelete : confirmClearAll}
        title={
          deleteId
            ? "Delete Entry?"
            : deleteTipId
            ? "Delete Tip Expense?"
            : "Clear All Data?"
        }
        description={
          deleteId
            ? "This will permanently delete this entry. This action cannot be undone."
            : deleteTipId
            ? "This will permanently delete this tip expense. This action cannot be undone."
            : "This will permanently delete all your betting entries, capital injections, and tip expenses. This action cannot be undone."
        }
      />

      <input
        ref={fileInputRef}
        type="file"
        accept=".csv"
        onChange={handleFileUpload}
        style={{ display: "none" }}
        data-testid="input-csv-file"
      />
    </div>
  );
}
